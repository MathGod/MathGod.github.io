<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mathgod.github.io/</id>
    <title>老王博客</title>
    <updated>2020-02-24T13:00:32.497Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mathgod.github.io/"/>
    <link rel="self" href="https://mathgod.github.io/atom.xml"/>
    <subtitle>记录生活点滴、分享前端技术。</subtitle>
    <logo>https://mathgod.github.io/images/avatar.png</logo>
    <icon>https://mathgod.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 老王博客</rights>
    <entry>
        <title type="html"><![CDATA[一键为网站添加夜间模式]]></title>
        <id>https://mathgod.github.io/YDsxJyHzj</id>
        <link href="https://mathgod.github.io/YDsxJyHzj">
        </link>
        <updated>2020-02-24T12:41:13.000Z</updated>
        <summary type="html"><![CDATA[<p>直接在博客任意位置如footer.html文件插入</p>
<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/darkmode-js@1.5.5/lib/darkmode-js.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  new Darkmode({left: '32px',label: '🌓'}).showWidget();
&lt;/script&gt;
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>直接在博客任意位置如footer.html文件插入</p>
<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/darkmode-js@1.5.5/lib/darkmode-js.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  new Darkmode({left: '32px',label: '🌓'}).showWidget();
&lt;/script&gt;
</code></pre>
<!-- more -->
<p>具体配置可到官网https://darkmodejs.learn.uno/</p>
<h2 id="注意">注意</h2>
<p>不要使用360浏览器！<br>
不要使用360浏览器！<br>
360浏览器兼容性不好。会出现严重闪屏、内容缺失的奇怪问题，谷歌和火狐浏览器则正常，但背景图片会被自动隐藏，所以该模式不适合放在有背景图片的博客首页，放在内容页比较好。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PWA技术使用规律学习笔记]]></title>
        <id>https://mathgod.github.io/CZYN-poCW</id>
        <link href="https://mathgod.github.io/CZYN-poCW">
        </link>
        <updated>2020-02-21T09:26:08.000Z</updated>
        <summary type="html"><![CDATA[<p>PWA全称Progressive Web App，即渐进式WEB应用。<br>
 <br>
近年来逐渐流行，它主要功能是再移动端自动弹出添加网站到桌面图标的提示。可避免开发原生APP昂贵成本且用户免安装更新，对APP开发者和用户都有好处。<br>
 <br>
安卓阵营浏览器几乎都支持，只差苹果了。经过测试，常用网站中支持PWA的有百度，哔哩哔哩，微博，推特。个人博客中使用的还是较少数，可能是大家还没发现。<br>
 <br>
看了上十篇PWA相关文章再反复测试，发现了一些使用规律。</p>
]]></summary>
        <content type="html"><![CDATA[<p>PWA全称Progressive Web App，即渐进式WEB应用。<br>
 <br>
近年来逐渐流行，它主要功能是再移动端自动弹出添加网站到桌面图标的提示。可避免开发原生APP昂贵成本且用户免安装更新，对APP开发者和用户都有好处。<br>
 <br>
安卓阵营浏览器几乎都支持，只差苹果了。经过测试，常用网站中支持PWA的有百度，哔哩哔哩，微博，推特。个人博客中使用的还是较少数，可能是大家还没发现。<br>
 <br>
看了上十篇PWA相关文章再反复测试，发现了一些使用规律。</p>
<!-- more -->
<p>先看效果<br>
 <br>
移动端<br>
<img src="https://mathgod.github.io//post-images/1582279031262.jpg" alt="" loading="lazy"><br>
<img src="https://mathgod.github.io//post-images/1582279055237.jpg" alt="" loading="lazy"><br>
谷歌浏览器<br>
<img src="https://mathgod.github.io//post-images/1582279080801.PNG" alt="" loading="lazy"><br>
<img src="https://mathgod.github.io//post-images/1582279099136.PNG" alt="" loading="lazy"><br>
<img src="https://mathgod.github.io//post-images/1582279108196.PNG" alt="" loading="lazy"></p>
<p>PWA并不是单指某一项技术，你更可以把它理解成是一种思想和概念，目的就是对标原生app，将Web网站通过一系列的Web技术去优化它，提升其安全性，性能，流畅性，用户体验等各方面指标，最后达到用户就像在用app一样的感觉。</p>
<p>PWA中包含的核心功能及特性如下：<br>
1.可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏<br>
2.实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能<br>
3.实现了消息推送</p>
<h3 id="使用方法">使用方法</h3>
<p>网站首页载入manifest.json文件</p>
<pre><code>&lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot;&gt;
</code></pre>
<p>manifest.json文件内容</p>
<pre><code>{
&quot;name&quot;: &quot;Hi,MathGod&quot;,
&quot;short_name&quot;: &quot;MathGod&quot;,
&quot;start_url&quot;: &quot;/&quot;,
&quot;display&quot;: &quot;standalone&quot;,
&quot;theme_color&quot;: &quot;#fff&quot;,
&quot;background_color&quot;: &quot;#fff&quot;,
&quot;icons&quot;: [
	{
		&quot;src&quot;: &quot;192.png&quot;,
		&quot;sizes&quot;: &quot;192x192&quot;,
		&quot;type&quot;: &quot;image/png&quot;
	}	
]   
}
</code></pre>
<p>引入sw.js</p>
<pre><code>&lt;script&gt;
if ('serviceWorker' in navigator) {
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js');
});
}
&lt;/script&gt;
</code></pre>
<p>sw.js文件内容</p>
<pre><code>self.addEventListener('fetch', function (evt) {
console.log('sw fetch() 发送的请求', evt.request.url)
})
</code></pre>
<p>最后加个图标文件192.png</p>
<h3 id="使用注意">使用注意</h3>
<p>上述代码和文件都必须放在网站首页面，不然无法实现功能。<br>
sw.js文件内容可以为空，甚至不存在此文件都能实现功能。只需要有引用sw.js的代码。<br>
甚至只需要第一次含有引用sw.js代码，网站打开过，然后把引用sw.js的程序删掉，只剩下载入manifest.json文件的代码和manifest.json文件本身，也可实现功能。</p>
<p>定时推送功能还在探索中...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nodejs是用来做什么的]]></title>
        <id>https://mathgod.github.io/ZgezxDefR</id>
        <link href="https://mathgod.github.io/ZgezxDefR">
        </link>
        <updated>2020-02-17T11:41:00.000Z</updated>
        <summary type="html"><![CDATA[<p>如果你去年注意过技术方面的新闻，我敢说你至少看到node.js不下一两次。那么问题来了“node.js是什么？”。有些人没准会告诉你“这是一种通过JavaScript语言开发web服务端的东西”。如果这种晦涩解释还没把你搞晕，你没准会接着问：“为什么我们要用node.js？”，别人一般会告诉你：node.js有非阻塞，事件驱动I/O等特性，从而让高并发（high concurrency）在的轮询（Polling）和comet构建的应用中成为可能。<br>
 <br>
当你看完这些解释觉得跟看天书一样的时候，你估计也懒得继续问了。不过没事。我这篇文章就是在避开高端术语的同时，帮助你你理解node.js的。<br>
 <br>
浏览器给网站发请求的过程一直没怎么变过。当浏览器给网站发了请求。服务器收到了请求，然后开始搜寻被请求的资源。如果有需要，服务器还会查询一下数据库，最后把响应结果传回浏览器。不过，在传统的web服务器中（比如Apache），每一个请求都会让服务器创建一个新的进程来处理这个请求。<br>
 </p>
]]></summary>
        <content type="html"><![CDATA[<p>如果你去年注意过技术方面的新闻，我敢说你至少看到node.js不下一两次。那么问题来了“node.js是什么？”。有些人没准会告诉你“这是一种通过JavaScript语言开发web服务端的东西”。如果这种晦涩解释还没把你搞晕，你没准会接着问：“为什么我们要用node.js？”，别人一般会告诉你：node.js有非阻塞，事件驱动I/O等特性，从而让高并发（high concurrency）在的轮询（Polling）和comet构建的应用中成为可能。<br>
 <br>
当你看完这些解释觉得跟看天书一样的时候，你估计也懒得继续问了。不过没事。我这篇文章就是在避开高端术语的同时，帮助你你理解node.js的。<br>
 <br>
浏览器给网站发请求的过程一直没怎么变过。当浏览器给网站发了请求。服务器收到了请求，然后开始搜寻被请求的资源。如果有需要，服务器还会查询一下数据库，最后把响应结果传回浏览器。不过，在传统的web服务器中（比如Apache），每一个请求都会让服务器创建一个新的进程来处理这个请求。<br>
 </p>
<!-- more -->
<p>后来有了Ajax。有了Ajax，我们就不用每次都请求一个完整的新页面了，取而代之的是，每次只请求需要的部分页面信息就可以了。这显然是一个进步。但是比如你要建一个FriendFeed这样的社交网站（类似人人网那样的刷朋友新鲜事的网站），你的好友会随时的推送新的状态，然后你的新鲜事会实时自动刷新。要达成这个需求，我们需要让用户一直与服务器保持一个有效连接。目前最简单的实现方法，就是让用户和服务器之间保持长轮询（long polling）。<br>
 <br>
HTTP请求不是持续的连接，你请求一次，服务器响应一次，然后就完了。长轮训是一种利用HTTP模拟持续连接的技巧。具体来说，只要页面载入了，不管你需不需要服务器给你响应信息，你都会给服务器发一个Ajax请求。这个请求不同于一般的Ajax请求，服务器不会直接给你返回信息，而是它要等着，直到服务器觉得该给你发信息了，它才会响应。比如，你的好友发了一条新鲜事，服务器就会把这个新鲜事当做响应发给你的浏览器，然后你的浏览器就刷新页面了。浏览器收到响应刷新完之后，再发送一条新的请求给服务器，这个请求依然不会立即被响应。于是就开始重复以上步骤。利用这个方法，可以让浏览器始终保持等待响应的状态。虽然以上过程依然只有非持续的Http参与，但是我们模拟出了一个看似持续的连接状态<br>
 <br>
我们再看传统的服务器（比如Apache）。每次一个新用户连到你的网站上，你的服务器就得开一个连接。每个连接都需要占一个进程，这些进程大部分时间都是闲着的（比如等着你好友发新鲜事，等好友发完才给用户响应信息。或者等着数据库返回查询结果什么的）。虽然这些进程闲着，但是照样占用内存。这意味着，如果用户连接数的增长到一定规模，你服务器没准就要耗光内存直接瘫了。<br>
 <br>
这种情况怎么解决？解决方法就是刚才上边说的：<strong>非阻塞</strong>和<strong>事件驱动</strong>。这些概念在我们谈的这个情景里面其实没那么难理解。你把非阻塞的服务器想象成一个loop循环，这个loop会一直跑下去。一个新请求来了，这个loop就接了这个请求，把这个请求传给其他的进程（比如传给一个搞数据库查询的进程），然后响应一个回调（callback）。完事了这loop就接着跑，接其他的请求。这样下来。服务器就不会像之前那样傻等着数据库返回结果了。<br>
 <br>
如果数据库把结果返回来了，loop就把结果传回用户的浏览器，接着继续跑。在这种方式下，你的服务器的进程就不会闲着等着。从而在理论上说，同一时刻的数据库查询数量，以及用户的请求数量就没有限制了。服务器只在用户那边有事件发生的时候才响应，这就是<strong>事件驱动</strong>。<br>
 <br>
FriendFeed是用基于Python的<strong>非阻塞</strong>框架Tornado (知乎也用了这个框架) 来实现上面说的新鲜事功能的。不过，Node.js就比前者更妙了。Node.js的应用是通过javascript开发的，然后直接在Google的变态V8引擎上跑。用了Node.js，你就不用担心用户端的请求会在服务器里跑了一段能够造成阻塞的代码了。因为javascript本身就是事件驱动的脚本语言。<br>
 <br>
你回想一下，在给前端写javascript的时候，更多时候你都是在搞事件处理和回调函数。javascript本身就是给事件处理量身定制的语言。Node.js还是处于初期阶段。如果你想开发一个基于Node.js的应用，你应该会需要写一些很底层代码。但是下一代浏览器很快就要采用WebSocket技术了，从而长轮询也会消失。在Web开发里，Node.js这种类型的技术只会变得越来越重要。<br>
 <br>
作者：厂长<br>
链接：https://www.zhihu.com/question/<br>
33578075/answer/56951771<br>
来源：知乎<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[markdown插入代码块和代码高亮语法]]></title>
        <id>https://mathgod.github.io/cpWjmHxi9</id>
        <link href="https://mathgod.github.io/cpWjmHxi9">
        </link>
        <updated>2020-02-13T01:36:58.000Z</updated>
        <summary type="html"><![CDATA[<p><em>浏览别技术博客时经常能看到代码块，预想写教程时免不了要插入代码，于是今天花了一个早上研究了markdown代码块语法，并顺便写个教程。</em><br>
 </p>
<h2 id="单行代码">单行代码</h2>
<h3 id="方法">方法：</h3>
<p>代码之间分别用一个反引号包起来</p>
<pre><code class="language-markdown">'Hello World'
</code></pre>
<h3 id="效果">效果：</h3>
<p><code>Hello World</code></p>
<p> <br>
 </p>
<h2 id="多行代码">多行代码</h2>
<h3 id="方法-2">方法:</h3>
<p>代码之间分别用三个反引号```包起来，且两边的反引号各单独占一行。</p>
<pre><code>```
function fun(){
echo $a;
echo &quot;这是一句非常牛逼的代码&quot;;
print(&quot;Hello, World!&quot;);
}
```
</code></pre>
<h3 id="效果-2">效果：</h3>
<pre><code>function fun(){
  echo $a;
  echo &quot;这是一句非常牛逼的代码&quot;;
  print(&quot;Hello, World!&quot;);
}
fun();
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p><em>浏览别技术博客时经常能看到代码块，预想写教程时免不了要插入代码，于是今天花了一个早上研究了markdown代码块语法，并顺便写个教程。</em><br>
 </p>
<h2 id="单行代码">单行代码</h2>
<h3 id="方法">方法：</h3>
<p>代码之间分别用一个反引号包起来</p>
<pre><code class="language-markdown">'Hello World'
</code></pre>
<h3 id="效果">效果：</h3>
<p><code>Hello World</code></p>
<p> <br>
 </p>
<h2 id="多行代码">多行代码</h2>
<h3 id="方法-2">方法:</h3>
<p>代码之间分别用三个反引号```包起来，且两边的反引号各单独占一行。</p>
<pre><code>```
function fun(){
echo $a;
echo &quot;这是一句非常牛逼的代码&quot;;
print(&quot;Hello, World!&quot;);
}
```
</code></pre>
<h3 id="效果-2">效果：</h3>
<pre><code>function fun(){
  echo $a;
  echo &quot;这是一句非常牛逼的代码&quot;;
  print(&quot;Hello, World!&quot;);
}
fun();
</code></pre>
<!-- more -->
<p> <br>
 </p>
<h2 id="代码高亮">代码高亮</h2>
<h3 id="方法-3">方法：</h3>
<p>在第一行的三个反引号```后面加php或python等词可代码高亮。</p>
<pre><code>```php
function fun(){
 $a=123;
 echo &quot;这是一句非常牛逼的代码&quot;;
 print(&quot;Hello, World!&quot;);
}
fun();
```  
</code></pre>
<p> </p>
<pre><code>```python
function fun(){
 $a=123;
 echo &quot;这是一句非常牛逼的代码&quot;;
 print(&quot;Hello, World!&quot;);
}
fun();
```
</code></pre>
<h3 id="加php的效果">加php的效果：</h3>
<pre><code class="language-php">function fun(){
  $a=123;
  echo &quot;这是一句非常牛逼的代码&quot;;
  print(&quot;Hello, World!&quot;);
}
fun();
</code></pre>
<h3 id="加python的效果">加python的效果：</h3>
<pre><code class="language-python">function fun(){
  $a=123;
  echo &quot;这是一句非常牛逼的代码&quot;;
  print(&quot;Hello, World!&quot;);
}
fun();
</code></pre>
<p> <br>
 </p>
<h2 id="防转译">防转译</h2>
<h3 id="方法-4">方法：</h3>
<p>每行缩进 4 个空格，缩进式插入前方必须有空行。</p>
<h3 id="作用">作用 ：</h3>
<p>此方法可防止转译，主要用来写教程，因为教程的示例代码不长，每行单独空四格也不会浪费太多时间，而展示太长代码则此方法不适用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[6毛进价口罩卖1块钱违法，那卖7毛钱也违法喽？]]></title>
        <id>https://mathgod.github.io/IwlSMQGZk</id>
        <link href="https://mathgod.github.io/IwlSMQGZk">
        </link>
        <updated>2020-02-13T00:24:50.000Z</updated>
        <summary type="html"><![CDATA[<p>按7毛钱卖的话购销差价额也超过15%了。（0.7-0.6）/0.6=16.7%<br>
 <br>
湖北的新闻一次又一次刷新我的认知下限</p>
]]></summary>
        <content type="html"><![CDATA[<p>按7毛钱卖的话购销差价额也超过15%了。（0.7-0.6）/0.6=16.7%<br>
 <br>
湖北的新闻一次又一次刷新我的认知下限</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[本打算年后回到公司就提辞职的，由于假期延长一拖再拖。]]></title>
        <id>https://mathgod.github.io/r0p4CTNqT</id>
        <link href="https://mathgod.github.io/r0p4CTNqT">
        </link>
        <updated>2020-02-11T14:08:15.000Z</updated>
        <content type="html"><![CDATA[<p>今天是年后上班的第二天。下午，厂里有个员工测出高温，于是公司突然宣布又多放五天假。打电话给120处理了。</p>
<p>晚上的时候，听保安说，那个员工体温又正常了，说他过年没回家一直留在厂里，应该是泡面吃多了上火...然而放假通知已经发出去收不回来了。</p>
<p>考虑到员工安全，公司决定不给住宿的人离开公司。所以我又要在宿舍呆多5天，要是一个人住还好，然而还有爱外放吵闹的舍友（集体间）。这种宿舍住得一点都不爽，影响作息，也是我想辞职的原因。（别问我为什么不外面租房，那点工资经不起折腾）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从输入URL到页面加载发生了什么？]]></title>
        <id>https://mathgod.github.io/bQ0Q2_4_0</id>
        <link href="https://mathgod.github.io/bQ0Q2_4_0">
        </link>
        <updated>2020-02-06T13:30:18.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="总体来说分为以下几个过程">总体来说分为以下几个过程:</h4>
<p>1.DNS解析<br>
2.TCP连接<br>
3.发送HTTP请求<br>
4.服务器处理HTTP请求<br>
5.页面渲染<br>
6.断开TCP连接</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="总体来说分为以下几个过程">总体来说分为以下几个过程:</h4>
<p>1.DNS解析<br>
2.TCP连接<br>
3.发送HTTP请求<br>
4.服务器处理HTTP请求<br>
5.页面渲染<br>
6.断开TCP连接</p>
<!-- more -->
<p>仔细思考这个问题，发现确实很深，这个过程涉及到的东西很多。这个问题的回答真的能够很好的考验一个web工程师的水平<br>
注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，<br>
而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、<br>
到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；</p>
<h1 id="1dns解析">1.DNS解析</h1>
<p>DNS查询顺序如下，若其中一步成功则直接跳到建立链接部分：</p>
<p>浏览器自身DNS<br>
操作系统DNS<br>
本地hosts文件<br>
向域名服务器发送请求</p>
<h1 id="2tcp连接">2.TCP连接</h1>
<p>TCP三次握手(three-way handshaking)</p>
<p>发送方:SYN(synchronize)<br>
接收方:SYN/ACK(acknowledgement),确认信息传达<br>
发送方:ACK - 确认接收方在线可收消息，握手结束<br>
Accept<br>
<img src="https://mathgod.github.io//post-images/1581082610268.jpg" alt="" loading="lazy"><br>
（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。</p>
<p>（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。</p>
<p>（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</p>
<p>TCP三次握手的的好处在于：发送方可以确认接收方仍然在线，不会因为白发送而浪费资源。</p>
<h2 id="https协议">HTTPS协议</h2>
<p>为什么要把HTTPS协议放在这里讲呢？</p>
<p>因为HTTP报文是包裹在TCP报文中发送的，服务端收到TCP报文时候会解包提取出HTTP报文。<br>
但是这个过程中存在一定的风险。HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的危险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(or TLS)<br>
<img src="https://mathgod.github.io//post-images/1581082668788.jpg" alt="" loading="lazy"></p>
<h2 id="https过程">HTTPS过程</h2>
<p>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客TLS/SSL握手过程。<br>
HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，<br>
是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。</p>
<h1 id="3发送http请求">3.发送HTTP请求</h1>
<p>构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。<br>
HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。</p>
<p>请求行：<br>
Method Request-URL HTTP-Version CRLF</p>
<p>请求报头<br>
请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br>
PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。<br>
常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。</p>
<p>事件循环(Event loop)<br>
js是单线程，js解析方法时，将同步任务排队到执行栈中，异步任务排队到事件队列中。<br>
事件队列分为:<br>
宏任务：setTimeout，setInterval，setImmediate，I/O，UI交互事件<br>
微任务：process.nextTick，Promise.then<br>
浏览器环境中执行方法时，先将执行栈中的任务清空，再将微任务推到执行栈中并清空，之后检查是否存在宏任务，若存在则取出一个宏任务，执行完成检查是否有微任务，以此循环…</p>
<h1 id="4-服务器处理http请求并返回http报文">4. 服务器处理HTTP请求并返回HTTP报文</h1>
<p>HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。</p>
<h1 id="5浏览器解析渲染页面">5.浏览器解析渲染页面</h1>
<p>使用HTML创建文件对象类型（DOM）<br>
使用CSS创建CSS对象类型（CSSOM）<br>
基于DOM和CSSOM执行脚本（Scripts）<br>
合并DOM和CSSOM形成渲染树（Render Tree)<br>
使用渲染布局（Layout）所有元素渲染（Paint）所有元素</p>
<h1 id="6断开tcp连接4次挥手">6.断开TCP连接（4次挥手）</h1>
<p>(https://cdn.ru23.com/img/2018/12/tcp4次挥手.png)<br>
四次分手<br>
第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；<br>
第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；<br>
第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；<br>
第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p>
<p>为什么要四次分手<br>
那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>
<p>文章参考： https://ru23.com/note/e277deca.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[m3u8格式视频探索]]></title>
        <id>https://mathgod.github.io/m3u8</id>
        <link href="https://mathgod.github.io/m3u8">
        </link>
        <updated>2020-02-03T09:51:29.000Z</updated>
        <content type="html"><![CDATA[<p>过年整天在家没事做，到处看各种视频电影。</p>
<p>今天不小心点开一个有趣视频的网站，于是想下载其中一些到本地。</p>
<p>第一步我肯定是找下载按钮的，不出意外当然找不到。</p>
<p>然后对着视频单击右键，毫无疑问再次找不到另存视频按键。</p>
<p>是时候展现真正的技术了！</p>
<p>接下来肯定是按F12打开开发者选项的networok了，然后找了半天还是没找到视频文件。</p>
<p>一直找一直找还是没找到，我开始懵逼了。？？？不应该呀</p>
<p>找了半天看到两个以.m3u8为后缀的文件，但是文件很小，所以不可能包含整个视频文件。</p>
<p>但我印象中m3u8肯定跟视频有关联，是一种视频格式。</p>
<p>接下来我就看到上百个.ts文件，每个ts文件1M左右，内容是10秒左右的视频。</p>
<p>所以我就理解为m3u8视频是由多个文件拼接的一种视频格式。百度了下也差不多这个意思。</p>
<p>只能百度继续找m3u8视频下载方法。</p>
<p>百度大多数的方法是先用插件把每个ts视频下载出来，然后再合并。我按百度方法下载了某个插件，<br>
然后开始下载了一部视频，在浏览器加载完200多个ts视频时已经很卡了，点下载也没什么反应。<br>
思索许久，发现下载几百个文件再合成视频不太现实，万一漏下载某个文件就无法保证合成成功。<br>
所以这个方法被放弃了。</p>
<p>继续百度搜寻其他方法，最终在[52破解]下载到一个神奇的插件，<br>
直接能抓取m3u8视频并下载。</p>
<p>这个插件还是挺好用的，大多数情况可同时下载多个视频，少数情况多部视频下载会出问题（下载的视频都看不了），<br>
研究了下可能是网络不好就会出问题。而且该插件无法在360浏览器使用，谷歌浏览器用着挺正常，火狐的还没测试过。</p>
<p>插件下载链接晚点放上来，也可直接联系我拿。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发现个有趣规律，晚上网络比早上慢得多]]></title>
        <id>https://mathgod.github.io/Jo40s-Ks6</id>
        <link href="https://mathgod.github.io/Jo40s-Ks6">
        </link>
        <updated>2020-02-01T14:42:43.000Z</updated>
        <content type="html"><![CDATA[<p>早上中午之前网络都很好，晚上点以后网络不给力，由此可推断出上网主力军大多晚睡晚起。</p>
<p>所以我决定早睡早起，错峰上网。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[教初三妹妹学习真的好累。]]></title>
        <id>https://mathgod.github.io/S3pLvWBb_</id>
        <link href="https://mathgod.github.io/S3pLvWBb_">
        </link>
        <updated>2020-01-30T14:27:04.000Z</updated>
        <content type="html"><![CDATA[<p>她真的很差，又懒又蠢作息异常还不肯改。不知道几个月后能否考上高中，哪怕是县里最差的高中也好。</p>
]]></content>
    </entry>
</feed>