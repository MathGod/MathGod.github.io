<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mathgod.github.io/</id>
    <title>老王博客</title>
    <updated>2020-06-07T13:16:11.963Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mathgod.github.io/"/>
    <link rel="self" href="https://mathgod.github.io/atom.xml"/>
    <subtitle>专注php、js编程，博客、论坛开发。</subtitle>
    <logo>https://mathgod.github.io/images/avatar.png</logo>
    <icon>https://mathgod.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 老王博客</rights>
    <entry>
        <title type="html"><![CDATA[国企校招面试非技术性问题总结]]></title>
        <id>https://mathgod.github.io/mBIu0BR3-</id>
        <link href="https://mathgod.github.io/mBIu0BR3-">
        </link>
        <updated>2020-06-07T13:01:14.000Z</updated>
        <content type="html"><![CDATA[<p>上一份工作收获<br>
谈谈对岗位/行业的理解<br>
职业规划<br>
为什么选择这个企业/公司<br>
为什么选这个城市/觉得这个城市怎样<br>
对加班的看法<br>
对薪资要求<br>
这岗位的优势<br>
有什么缺点<br>
家庭环境怎样</p>
<p>对5G的理解，应用<br>
高数据速率、减少延迟、节省能源、降低成本、提高系统容量和大规模设备连接<br>
车联网与自动驾驶   智能电网   外科手术<br>
结合简历问问题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何为你的代码选择一个开源协议]]></title>
        <id>https://mathgod.github.io/K5jVUCLcY</id>
        <link href="https://mathgod.github.io/K5jVUCLcY">
        </link>
        <updated>2020-06-06T13:57:50.000Z</updated>
        <content type="html"><![CDATA[<p>如何为代码选择开源许可证，这是一个问题。</p>
<p>世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种----GPL、BSD、MIT、Mozilla、Apache和LGPL----之中做选择，也很复杂。</p>
<p>乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。这是我见过的最简单的讲解，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。</p>
<p>下面是我制作的中文版，请点击看大图。</p>
<figure data-type="image" tabindex="1"><img src="https://mathgod.github.io//post-images/1591452377041.png" alt="" loading="lazy"></figure>
<p>转自https://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP随机输出一句话]]></title>
        <id>https://mathgod.github.io/xtN-lu6aO</id>
        <link href="https://mathgod.github.io/xtN-lu6aO">
        </link>
        <updated>2020-06-06T13:31:53.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-javascript">function random_str () { 
$poems=&quot;从善如登，从恶如崩。 
已知花意，未见其花，已见其花，未闻花名 
如果能不长大就好了啊 可是时光在身后挡住退路。 
或许前路永夜，即便如此我也要前进，因为星光即使微弱也会为我照亮前路 
你驻足于春色中，于那独一无二的春色之中
喜欢的人喜欢别人不是很正常吗。
生活是不公平的；要去适应它。——比尔盖茨
人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以自始至终陪着走完。当陪你的人要下车时，即使不舍也该心存感激，然后挥手道别。&quot;; 
$poems=explode(&quot;\n&quot;,$poems); 
return $poems[rand(0,count($poems)-1)]; 
} 
function says(){ 
$says=random_str(); 
echo $says; 
} 
</code></pre>
<p>explode(separator,string,limit)<br>
作用：把字符串以“separator”格式打散成数组，存储在“string”里面。limit是可选参数。</p>
<p>rand(0,count($poems)-1)<br>
在0，和数组的长度大小 里面随机取一个。和C语言有点类似。</p>
<p>最后在需要的地方，写上这个代码就行：</p>
<p><code>&lt;?php says(); ?&gt;</code></p>
<p>转自https://www.ihewro.com/archives/350/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[xx.c文件中往往会调用xx.h文件，即自己调用自己的 .h文件，为什么？]]></title>
        <id>https://mathgod.github.io/xQrvjziHk</id>
        <link href="https://mathgod.github.io/xQrvjziHk">
        </link>
        <updated>2020-06-05T13:32:14.000Z</updated>
        <content type="html"><![CDATA[<p>主要是为了解决定义与调用之间的混乱（C语言要求调用之前必须要先声明，一般include 同名.h会放在.c文件的开头，这是一种代码贵伐，增加程序的可读性）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大后天移动面试，被分到网络组，临时去百度补下网络知识。]]></title>
        <id>https://mathgod.github.io/HjaPXiO5q</id>
        <link href="https://mathgod.github.io/HjaPXiO5q">
        </link>
        <updated>2020-06-05T12:20:53.000Z</updated>
        <content type="html"><![CDATA[<p>也不知道面试会问啥，网上随便搜搜，能增加点信心也好。</p>
<h1 id="同源策略">同源策略</h1>
<p>两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。<br>
是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以xyz.com下的js脚本采用ajax读取abc.com里面的文件数据是会被拒绝的。</p>
<h1 id="不同网络层的作用">不同网络层的作用</h1>
<p>1、物理层：比特<br>
主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</p>
<p>2、数据链路层：帧<br>
定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。</p>
<p>3、网络层：数据报<br>
在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</p>
<p>4、运输层：报文段/用户数据报<br>
定义了一些传输数据的协议和端口号（WWW端口80等），如：<br>
TCP（transmission control protocol –传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）<br>
UDP（user datagram protocol–用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</p>
<p>5、会话层：<br>
通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）</p>
<p>6、表示层：<br>
可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</p>
<p>7.应用层：报文</p>
<h1 id="端口号">端口号：</h1>
<p>POP3 110 ,SMTP 25, FTP 21/20,dns u53,https 443,oracle 1521,ssh 22</p>
<h1 id="ftp-20-21端口分别是干什么的">FTP 20 21端口分别是干什么的？</h1>
<p>上传和下载。 21端口用于连接，bai20端口用于传输数据。</p>
<p>进行FTP文件传输中，客户端zhi首先连接到daoFTP服务器的21端口，进行用户的认证，认证成功后，要传输文件时，服务器会开一个端口为20来进行传输数据文件。</p>
<p>也就是说，端口20才是真正传输所用到的端口，端口21只用于FTP的登陆认证。我们平常下载文件时，会遇到下载到99%时，文件不完成，不能成功的下载。</p>
<p>其实是因为文件下载完毕后，还要在21端口再行进行用户认证，而下载文件的时间如果过长，客户机与服务器的21端口的连接会被服务器认为是超时连接而中断掉，就是这个原因。解决方法就是设置21端口的响应时间。</p>
<p>HTTP与HTTPS的区别<br>
HTTPS是加密传输协议，HTTP是名文传输协议;<br>
HTTPS需要用到SSL证书，而HTTP不用;<br>
HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO<br>
HTTPS标准端口443，HTTP标准端口80;<br>
HTTPS基于传输层，HTTP基于应用层;<br>
HTTPS在浏览器显示绿色安全锁，HTTP没有显示;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[支付宝[当面付]接口竟然可以个人用户申请]]></title>
        <id>https://mathgod.github.io/ia-k55xPx</id>
        <link href="https://mathgod.github.io/ia-k55xPx">
        </link>
        <updated>2020-06-02T04:12:55.000Z</updated>
        <content type="html"><![CDATA[<p>前两天在V2EX看到有人用自己申请的支付宝接口做了个发卡网站</p>
<p>该服务叫支付宝当面付基础版</p>
<p>营业执照可不填，只要上传一张门店照片(网上找)，申请秒通过。实名认证过的个人用户（非个体工商户）都可申请</p>
<p>费率只要千分之六，比第三方第四方平台都低得多。</p>
<p>提交营业执照的话费率可以更低，好像还有其他优惠。</p>
<p>话说，个人用户没有营业执照也可申请这个接口用于营业，难道不是涉嫌违法？希望大家把该接口用于学习，经营的话还是要有营业执照的。</p>
<p>官方demo不够完善，注意事项请看这篇文章<br>
https://www.cnblogs.com/woniu666/p/12799641.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js鼠标移入移出]]></title>
        <id>https://mathgod.github.io/P4iacpRgB</id>
        <link href="https://mathgod.github.io/P4iacpRgB">
        </link>
        <updated>2020-06-02T00:33:37.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-javascript">&lt;script&gt;
bb=document.getById('aa');

bb.onmouseenter=function(){
this.style.background='#ccc';
}
bb.onmouseleave=function(){
    //
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js全站变灰]]></title>
        <id>https://mathgod.github.io/yQackO7vM</id>
        <link href="https://mathgod.github.io/yQackO7vM">
        </link>
        <updated>2020-05-31T10:28:46.000Z</updated>
        <content type="html"><![CDATA[<p><code>&lt;html style=&quot;filter: grayscale(100%);&quot;&gt;</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js清除左右空格]]></title>
        <id>https://mathgod.github.io/-t9UI8or0</id>
        <link href="https://mathgod.github.io/-t9UI8or0">
        </link>
        <updated>2020-05-31T09:45:32.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-html">&lt;html&gt;
&lt;head&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script&gt;
var aa='   sdfsdf   ';
function trim(str){
return str.replace(/(^\s*)|(\s*$)/g,''); 
}
alert(trim(aa).length);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[回调函数]]></title>
        <id>https://mathgod.github.io/CDUpXPxjV</id>
        <link href="https://mathgod.github.io/CDUpXPxjV">
        </link>
        <updated>2020-05-31T05:03:44.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-javascript">//定义主函数，回调函数作为参数
function A(callback) {
    callback();  
    console.log('我是主函数');      
}

//定义回调函数
function B(){
    setTimeout(&quot;console.log('我是回调函数')&quot;, 3000);//模仿耗时操作  
}

//调用主函数，将函数B传进去
A(B);

//输出结果
我是主函数
我是回调函数
</code></pre>
<p>定义主函数的时候，我们让代码先去执行callback()回调函数，但输出结果却是后输出回调函数的内容。这就说明了主函数不用等待回调函数执行完，可以接着执行自己的代码。所以一般回调函数都用在耗时操作上面。比如ajax请求，比如处理文件等。</p>
]]></content>
    </entry>
</feed>